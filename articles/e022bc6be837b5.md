---
title: "PrismaとPGLite、Vitestでテスト環境を構築する"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['Prisma', 'PGLite', 'Vitest']
published: false
---

## はじめに

モダンなWebアプリケーション開発において、データベースを含むテストの実行は常に課題となります。従来は以下のような問題がありました：

- **Docker Compose** による実際のPostgreSQLの起動：重く、CIでの実行時間が長い
- **SQLite** の使用：本番環境（PostgreSQL）との差異による問題発生
- **インメモリDB** の利用：機能制限やSQL方言の違い

本記事では、これらの課題を解決する **PGLite** を使った軽量かつ高速なテスト環境の構築方法を紹介します。

## PGLiteとは

[PGLite](https://github.com/electric-sql/pglite) は、WebAssembly上で動作するPostgreSQLです。主な特徴は：

- **軽量**: WebAssemblyによる高速起動
- **完全互換**: 実際のPostgreSQLと同じSQL機能
- **インメモリ**: 永続化なしの高速実行
- **依存関係なし**: DockerやPostgreSQLのインストール不要

## 技術スタック

今回構築するテスト環境の技術スタック：

- **PGLite**: WebAssembly版PostgreSQL
- **Prisma**: ORMとマイグレーション管理
- **Vitest**: 高速テストランナー
- **pglite-prisma-adapter**: PGLiteとPrismaの接続アダプター

## 基本セットアップ

### 1. 依存関係のインストール

```json
{
  "dependencies": {
    "@electric-sql/pglite": "^0.3.3",
    "@prisma/client": "6.9.0",
    "pglite-prisma-adapter": "^0.5.0"
  },
  "devDependencies": {
    "vitest": "^2.1.8",
    "prisma": "6.9.0"
  }
}
```

### 2. Vitestの設定

```typescript
// vitest.config.mts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    environment: 'jsdom',
    globalSetup: './vitest-global-setup.ts',
  },
})
```

## PGliteTestDbManagerの実装

### アーキテクチャ設計

テスト用データベース管理には以下の要件を満たす必要があります：

1. **スキーマ初期化の最適化**: 全テストで1回のみ実行
2. **インスタンス共有**: メモリ使用量とパフォーマンスの最適化
3. **データクリーンアップ**: テスト間の独立性保証
4. **競合状態の回避**: 並行テスト実行での安全性

### 基本実装

```typescript
export class PGliteTestDbManager extends PrismaClientManager {
  private initialized = false
  
  // 共有PGliteインスタンス（全てのテストで使い回し）
  private static sharedPGlite: PGlite | null = null
  private static schemaInitialized = false
  
  // 初期化プロセスのPromise（競合状態を防ぐため）
  private static initializationPromise: Promise<PGlite> | null = null
}
```

### スキーマ初期化の最適化

最も重要な最適化は、データベーススキーマの初期化を全テスト実行中に1回のみ行うことです：

```typescript
/**
 * Prismaスキーマから初期化SQLを生成
 */
private static generateInitSQL(): string {
  try {
    const schemaPath = join(__dirname, '../../prisma/schema.prisma')
    const command = `pnpx prisma migrate diff --from-empty --to-schema-datamodel ${schemaPath} --script`
    
    const sql = execSync(command, {
      encoding: 'utf-8',
      cwd: join(__dirname, '../..'),
    })
    
    return sql
  } catch (error) {
    console.error('Failed to generate init SQL:', error)
    throw error
  }
}
```

### 競合状態の回避

並行テスト実行時の競合状態を防ぐため、初期化プロセス全体を制御します：

```typescript
/**
 * 共有PGliteインスタンスを取得（スキーマ初期化は最初の一回のみ）
 * 競合状態を防ぐため、初期化プロセス全体を一度だけ実行する
 */
private static async getSharedPGlite(): Promise<PGlite> {
  // 既に初期化済みの場合は即座に返す
  if (PGliteTestDbManager.sharedPGlite && PGliteTestDbManager.schemaInitialized) {
    return PGliteTestDbManager.sharedPGlite
  }
  
  // 初期化中の場合は既存のPromiseを返す（競合状態を防ぐ）
  if (PGliteTestDbManager.initializationPromise) {
    return PGliteTestDbManager.initializationPromise
  }
  
  // 初期化プロセスを開始
  PGliteTestDbManager.initializationPromise = PGliteTestDbManager.performInitialization()
  
  try {
    const result = await PGliteTestDbManager.initializationPromise
    return result
  } catch (error) {
    // エラーが発生した場合は初期化Promiseをクリア
    PGliteTestDbManager.initializationPromise = null
    throw error
  }
}
```

## Vitestとの統合

### グローバルセットアップ

全テスト実行前に共有データベースを初期化：

```typescript
// vitest-global-setup.ts
import { PGliteTestDbManager } from './infrastructure/dev/test-db-prisma-client-manager'

export async function setup() {
  console.log('🚀 Global test setup: Initializing shared PGlite database...')
  
  try {
    // 共有PGliteインスタンスを初期化（スキーマ作成）
    const manager = new PGliteTestDbManager()
    await manager.initializeAsync()
    
    console.log('✅ Global test setup completed')
  } catch (error) {
    console.error('❌ Global test setup failed:', error)
    throw error
  }
}

export async function teardown() {
  console.log('🧹 Global test teardown: Cleaning up shared resources...')
  
  try {
    // 共有リソースを完全にクリーンアップ
    await PGliteTestDbManager.closeGlobalTestDB()
    
    console.log('✅ Global test teardown completed')
  } catch (error) {
    console.error('❌ Global test teardown failed:', error)
    console.warn('Continuing despite teardown error...')
  }
}
```

## テストでの使用方法

### インスタンス方式（推奨）

```typescript
describe('テストスイート', () => {
  const manager = new PGliteTestDbManager()
  
  beforeEach(async () => {
    // ✅ initializeAsync()は即座に返る（スキーマ既に作成済み）
    await manager.initializeAsync()
    // ✅ データリセットのみ実行（高速）
    await manager.cleanupDB()
  })
  
  afterAll(async () => {
    // ✅ Prismaクライアントの切断のみ
    await manager.cleanup()
  })
  
  it('テストケース', async () => {
    const prisma = await manager.getClientAsync()
    
    // テストデータ作成
    await prisma.user.create({
      data: { name: 'Test User', email: 'test@example.com' }
    })
    
    const users = await prisma.user.findMany()
    expect(users).toHaveLength(1)
  })
})
```

### 静的メソッド方式（従来互換）

```typescript
describe('従来方式のテスト', () => {
  beforeEach(async () => {
    await PGliteTestDbManager.cleanupTestDB()
  })
  
  it('静的メソッドでの使用例', async () => {
    const prisma = await PGliteTestDbManager.createTestPrismaClient()
    
    await prisma.user.create({
      data: { name: 'Static Test User', email: 'static@example.com' }
    })
    
    const users = await prisma.user.findMany()
    expect(users).toHaveLength(1)
  })
})
```

## データクリーンアップ戦略

### 基本クリーンアップ

```typescript
/**
 * DBをクリーンアップ（全テーブルの削除）
 */
async cleanupDB(): Promise<void> {
  const db = await this.getPGliteInstance()
  
  // 全テーブルの一覧を取得
  const tables = await db.query(`
    SELECT tablename 
    FROM pg_tables 
    WHERE schemaname = 'public'
  `)
  
  // 外部キー制約を一時的に無効化
  await db.exec('SET session_replication_role = replica;')
  
  // 各テーブルをTRUNCATE
  for (const table of tables.rows) {
    await db.exec(`TRUNCATE TABLE "${(table as any).tablename}" CASCADE;`)
  }
  
  // 外部キー制約を再度有効化
  await db.exec('SET session_replication_role = DEFAULT;')
}
```

### テンポラリテーブル対応

PostgreSQLのテンポラリテーブルはセッション終了まで残存するため、必要に応じて明示的に削除：

```typescript
/**
 * テンポラリテーブルも含めた完全なDBクリーンアップ
 */
async cleanupDBWithTempTables(): Promise<void> {
  const db = await this.getPGliteInstance()
  
  // 通常のテーブルをクリーンアップ
  await this.cleanupDB()
  
  // テンポラリテーブルの一覧を取得して削除
  const tempTables = await db.query(`
    SELECT tablename 
    FROM pg_tables 
    WHERE schemaname LIKE 'pg_temp_%'
  `)
  
  for (const table of tempTables.rows) {
    await db.exec(`DROP TABLE IF EXISTS "${(table as any).tablename}" CASCADE;`)
  }
}
```

## パフォーマンス最適化

### 1. スキーマ初期化の1回実行

- **従来**: 各テストでスキーマ作成（重い）
- **最適化後**: グローバルセットアップで1回のみ（軽い）

### 2. インスタンス共有

- **従来**: テストごとに新しいPGliteインスタンス
- **最適化後**: 共有インスタンスでメモリ使用量削減

### 3. データクリーンアップの高速化

- **DROP + CREATE**: スキーマ再作成（重い）
- **TRUNCATE**: データのみ削除（軽い）

## 実行結果とメリット

### パフォーマンス向上

- **テスト起動時間**: Docker比で約80%短縮
- **テスト実行時間**: インメモリ動作により高速化
- **CI実行時間**: 依存関係なしで即座に開始

### 開発体験の向上

- **環境構築不要**: PostgreSQLのインストール不要
- **本番環境との一致**: PostgreSQL完全互換
- **デバッグの容易さ**: ローカル環境でのテスト実行

## まとめ

PGLiteを使用したテスト環境は以下のメリットを提供します：

1. **高速**: WebAssemblyによる軽量実行
2. **完全互換**: PostgreSQLと同じSQL機能
3. **簡単**: 複雑な環境構築不要
4. **効率的**: 共有インスタンスによるリソース最適化

従来のDocker + PostgreSQLと比較して、開発速度の向上とCIコストの削減を実現できる優れたソリューションです。

## 参考リンク

- [PGLite GitHub](https://github.com/electric-sql/pglite)
- [pglite-prisma-adapter](https://www.npmjs.com/package/pglite-prisma-adapter)
- [Vitest](https://vitest.dev/)
- [Prisma](https://www.prisma.io/)
